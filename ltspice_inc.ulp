#usage "The goal of this include file is to seperate the os-specific parts from the main Ltspice.ulp"
       "In this way I can focus any portability efforts on just this one file."
       "10/31/2016"
       "<author>Author:Alfred Zaffran, alf@cadsoft.de</author>"
       "<author>Author:Jorge Garcia, jorge.garcia@autodesk.com</author>"

/**********************************************************************************************************************
*                                               FILE FUNCTIONS                                                        *
**********************************************************************************************************************/

int check_files(string path, string file_ext) {
  return fileglob(SearchFiles, path + file_ext);
}


// ein Windows-Laufwerk beginnt mit "Buchstabe:\"
// suche nach ":/" hinter dem Laufwerksbuchstaben
void check_windows_root(void) {
  string drv;
  for(int d = SearchStartDrive; d <= SearchLastDrive; d++) {
    sprintf(drv, "%c:/", d);
    if (check_files(drv, "/")) {
      SearchRoot[SearchnRoot] = drv;
      SearchnRoot++;
    }
  }
  return;
}

/************************ die Suchschleife *******************************************************/
// searchfile   = die zu suchende Datei
// root         = der Start-Pfad ab dem gesucht werden soll, inkl. Laufwerkbuchstabe unter Windows
// maxiteration = die Tiefe, Anzahl der Verzweigung (Unterordner) ab dem root Pfad.
/*************************************************************************************************/
string file_search(string searchfile, string root, int maxiteration, string debugnum) {
  if (!root) {
    if (debugnum == "init") {
      dlgMessageBox("RUN ltspice.ulp with option Setup: "+searchfile, "CANCEL");
    }
    else {
      if (dlgMessageBox(debugnum + "\nUnknown path of file : "+searchfile, "OK", "CANCEL") == 0) return "";
    }
    exit(-752);
  }
  int len = strlen(root);
  if (root[len-1] != '/') root += "/"; // root muß mit Slash enden!
  if (!check_files(root, "")) {  // den Pfad prüfen
    return "";
  }
  // *** Betriebsystem feststellen ***
  // ******* Windows Laufwerke *******
  if (root) {
    SearchRoot[0] = root;
    SearchnRoot = 1;
  }
  else {
    check_windows_root();   // unter Windows die Laufwerke ermitteln
    //if (SearchnRoot) {
    //  sprintf(SearchRootfound, "Betriebssystem WINDOWS");
    //  for (int d = 0; d < SearchnRoot; d++) {
    //   SearchRootfound += SearchRoot[d] + "\n";
    //  }
    //}
    //int pos;
    // ************* Windows UNC-Pfad *****************
    //pos = strstr(root, "//", 0);  // windows hat bei UNC Namen zweimal Slash // am Anfang
    //check_UNC(root);
    //if (!SearchIs_UNC) if (project.board) project.board(B) check_UNC(B.name);
    //if (!SearchIs_UNC) if (project.schematic) project.schematic(S) check_UNC(S.name);
    //if (!SearchIs_UNC) if (library) library(L) check_UNC(L.name);

    // ************* LINUX File system ****************
    //if (!SearchRootfound) {
    //  pos = strstr(root, "/", 0);
    //  if (pos == 0) {
    //    sprintf(SearchRootfound, "Betriebsystem LINUX");
    //    if (check_files("/", "/")) {
    //      SearchRoot[SearchnRoot] = "/";
    //      SearchnRoot = 1;
    //    }
    //  }
    //}
  }

  int n, r;
  SearchStart = 0;
  SearchEnd = SearchnRoot;
  int iteration = 1;
  int finish = 0;
  int cntf;
  string searchfoundfile[];

  do {
    // 1. die Root-Ordner nach der Datei durchsuchen
    for (r = SearchStart; r < SearchEnd; r++) {
      status(SearchRoot[r]);                   // Anzeige des aktuellen Verzeichnisnamen
      n = check_files(SearchRoot[r], searchfile); // suche im Verzeichnis nach Datei
      if (n) {
        for (int f=0; f<n; f++) {
          searchfoundfile[cntf] = SearchFiles[f];
          return searchfoundfile[cntf]; // das erst gefunden File zurückgeben
          cntf++;
        }
      }
    }
    if (finish || (maxiteration && iteration == maxiteration)) break;

    // 2. die Root-Ordner nach Ordnern durchsuchen
    for (r = SearchStart; r < SearchEnd; r++) {
      sprintf(h, "%d %d %s", iteration, SearchnRoot, SearchRoot[r]);
      status(h);               // Anzeige des aktuellen Verzeichnisnamen
      n = fileglob(a, SearchRoot[r] + "/");      // lesen der Dateien
      if (n) {
        for (int xl = 0; xl < n; xl++) {
          sprintf(h, "%s\n", a[xl]);
          if (a[xl][strlen(a[xl])-1] == '/') { // nach Verzeichnis suchen
            SearchRoot[SearchnRoot] = a[xl];
            sprintf(h, "%d %d %s", iteration, SearchnRoot, SearchRoot[SearchnRoot]);
            status(h);             // Anzeige des aktuellen Verzeichnisnamen
            SearchnRoot++;
          }
          else {
            break;
          }
        }
      }
    }
    SearchStart = r;
    SearchEnd = SearchnRoot; // Suchende erweitern
    if (SearchStart == SearchEnd) {
      finish = 1;
    }
    iteration++;
  } while(SearchnRoot);
  return searchfoundfile[0];
}

/**********************************************************************************************************************
*                                       EXPORT AND IMPORT FUNCTIONS                                                   *
**********************************************************************************************************************/

// change Eagle slash in path names to backslash for windows
string lash2backslash(string s) {
  int pos;
  do {
    pos = strchr(s, '/');
    if (pos >= 0) s[pos] = '\\';
  } while(pos >= 0);
  return s;
}


// change backslash in windows path names to Eagle slash
string backslash2lash(string s) {
  int pos;
  do {
    pos = strchr(s, '\\');
    if (pos >= 0) s[pos] = '/';
  } while(pos >= 0);
  return s;
}

string checkapostroph(string s) {  // da der ganze String in ' eingeschlossen wird,
                                   // müssen die Apostrophen verdoppelt werden.
  string t[];
  int cnt;
  cnt = strsplit(t, s, '\''); // check Apostroph
  if (cnt > 1) {
    s = "";
    for (int i = 0; i < cnt; i++) {
      if (i == 0) {
        if (t[i]) s += t[i];
      }
      else if (i) s += "''" + t[i];
    }
  }
 return s;
}

int makedir(string root1, string subdir) {  /*** generate DOS command MKDIR ***/
  string DOScommand;
  sprintf(DOScommand, "CMD.EXE  /C MKDIR \"%s%s\"",  lash2backslash(root1), lash2backslash(subdir));
  system(DOScommand);
  string f[];
  int n = fileglob(f, root1 + subdir); // prüfe ob das Verzeichnis angelegt werden konnte.
  return n;
}

void call_system(string exportfile) {  // DOS comand execute
  string syscommand;
  // Das executable und der Dateiname müssen in " " eingeschlossen werden, wegen Spaces im Pfad-Dateinamen!
  sprintf(syscommand, "\"%s\" \"%s\"", lash2backslash(LTSpiceExecute), lash2backslash(exportfile));
  system(syscommand);  // externes Programm starten
  return;
}

void dosfilecopy( string source, string target, string option) {
  string DOScommand;
  sprintf(DOScommand, "XCOPY \"%s\" \"%s\" %s", lash2backslash(source), lash2backslash(target), option);
  /*
  dlgDialog("DOS command") {
    dlgHBoxLayout dlgSpacing(800);
    dlgStringEdit(DOScommand);
    dlgPushButton("ok") dlgAccept();
    dlgPushButton("esc") { dlgReject(); exit(-4056); }
  };
  */
  system(DOScommand);
  return;
}

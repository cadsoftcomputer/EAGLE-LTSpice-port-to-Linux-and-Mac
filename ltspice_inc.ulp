#usage "The goal of this include file is to seperate the os-specific parts from the main Ltspice.ulp"
       "In this way I can focus any portability efforts on just this one file."
       "10/31/2016"
       "<author>Author:Alfred Zaffran, alf@cadsoft.de</author>"
       "<author>Author:Jorge Garcia, jorge.garcia@autodesk.com</author>"

/**********************************************************************************************************************
*                                               FILE FUNCTIONS                                                        *
**********************************************************************************************************************/

// This function checks what operating system this ULP is running on. Verified 11/10/2016
string operatingsystem(void){
  int discover;
  string result;
  
  discover = strstr(OS_SIGNATURE, "Windows");
  if (discover < 0) {
    discover = strstr(OS_SIGNATURE, "Linux");
    if (discover < 0) {
      result = "MAC";
      return result;
    }
    else {
      result = "LINUX";
      return result;
    }
  }
  else {
    result = "WINDOWS";
    return result;
  }
}

int check_files(string path, string file_ext) {
  return fileglob(SearchFiles, path + file_ext);
}


// ein Windows-Laufwerk beginnt mit "Buchstabe:\"
// suche nach ":/" hinter dem Laufwerksbuchstaben
void check_windows_root(void) {
  string drv;
  for(int d = SearchStartDrive; d <= SearchLastDrive; d++) {
    sprintf(drv, "%c:/", d);
    if (check_files(drv, "/")) {
      SearchRoot[SearchnRoot] = drv;
      SearchnRoot++;
    }
  }
  return;
}

/************************ die Suchschleife *******************************************************/
// searchfile   = die zu suchende Datei
// root         = der Start-Pfad ab dem gesucht werden soll, inkl. Laufwerkbuchstabe unter Windows
// maxiteration = die Tiefe, Anzahl der Verzweigung (Unterordner) ab dem root Pfad.
/*************************************************************************************************/
string file_search(string searchfile, string root, int maxiteration, string debugnum) {
  if (!root) {
    if (debugnum == "init") {
      dlgMessageBox("RUN ltspice.ulp with option Setup: "+searchfile, "CANCEL");
    }
    else {
      if (dlgMessageBox(debugnum + "\nUnknown path of file : "+searchfile, "OK", "CANCEL") == 0) return "";
    }
    exit(-752);
  }
  int len = strlen(root);
  if (root[len-1] != '/') root += "/"; // root muß mit Slash enden!
  if (!check_files(root, "")) {  // den Pfad prüfen
    return "";
  }
  // *** Betriebsystem feststellen ***
  // ******* Windows Laufwerke *******
  if (root) {
    SearchRoot[0] = root;
    SearchnRoot = 1;
  }
  else {
    check_windows_root();   // unter Windows die Laufwerke ermitteln
    //if (SearchnRoot) {
    //  sprintf(SearchRootfound, "Betriebssystem WINDOWS");
    //  for (int d = 0; d < SearchnRoot; d++) {
    //   SearchRootfound += SearchRoot[d] + "\n";
    //  }
    //}
    //int pos;
    // ************* Windows UNC-Pfad *****************
    //pos = strstr(root, "//", 0);  // windows hat bei UNC Namen zweimal Slash // am Anfang
    //check_UNC(root);
    //if (!SearchIs_UNC) if (project.board) project.board(B) check_UNC(B.name);
    //if (!SearchIs_UNC) if (project.schematic) project.schematic(S) check_UNC(S.name);
    //if (!SearchIs_UNC) if (library) library(L) check_UNC(L.name);

    // ************* LINUX File system ****************
    //if (!SearchRootfound) {
    //  pos = strstr(root, "/", 0);
    //  if (pos == 0) {
    //    sprintf(SearchRootfound, "Betriebsystem LINUX");
    //    if (check_files("/", "/")) {
    //      SearchRoot[SearchnRoot] = "/";
    //      SearchnRoot = 1;
    //    }
    //  }
    //}
  }

  int n, r;
  SearchStart = 0;
  SearchEnd = SearchnRoot;
  int iteration = 1;
  int finish = 0;
  int cntf;
  string searchfoundfile[];

  do {
    // 1. die Root-Ordner nach der Datei durchsuchen
    for (r = SearchStart; r < SearchEnd; r++) {
      status(SearchRoot[r]);                   // Anzeige des aktuellen Verzeichnisnamen
      n = check_files(SearchRoot[r], searchfile); // suche im Verzeichnis nach Datei
      if (n) {
        for (int f=0; f<n; f++) {
          searchfoundfile[cntf] = SearchFiles[f];
          return searchfoundfile[cntf]; // das erst gefunden File zurückgeben
          cntf++;
        }
      }
    }
    if (finish || (maxiteration && iteration == maxiteration)) break;

    // 2. die Root-Ordner nach Ordnern durchsuchen
    for (r = SearchStart; r < SearchEnd; r++) {
      sprintf(h, "%d %d %s", iteration, SearchnRoot, SearchRoot[r]);
      status(h);               // Anzeige des aktuellen Verzeichnisnamen
      n = fileglob(a, SearchRoot[r] + "/");      // lesen der Dateien
      if (n) {
        for (int xl = 0; xl < n; xl++) {
          sprintf(h, "%s\n", a[xl]);
          if (a[xl][strlen(a[xl])-1] == '/') { // nach Verzeichnis suchen
            SearchRoot[SearchnRoot] = a[xl];
            sprintf(h, "%d %d %s", iteration, SearchnRoot, SearchRoot[SearchnRoot]);
            status(h);             // Anzeige des aktuellen Verzeichnisnamen
            SearchnRoot++;
          }
          else {
            break;
          }
        }
      }
    }
    SearchStart = r;
    SearchEnd = SearchnRoot; // Suchende erweitern
    if (SearchStart == SearchEnd) {
      finish = 1;
    }
    iteration++;
  } while(SearchnRoot);
  return searchfoundfile[0];
}

/**********************************************************************************************************************
*                                       EXPORT AND IMPORT FUNCTIONS                                                   *
**********************************************************************************************************************/

// change Eagle slash in path names to backslash for windows
string lash2backslash(string s, string os) {
  int pos;
  if (os == "WINDOWS") {
	do {
	  pos = strchr(s, '/');
      if (pos >= 0) s[pos] = '\\';
    } while(pos >= 0);
    return s;
  }
  return s;
}


// change backslash in windows path names to Eagle slash
string backslash2lash(string s, string os) {
  int pos;
  if (os == "WINDOWS") {
    do {
      pos = strchr(s, '\\');
      if (pos >= 0) s[pos] = '/';
    } while(pos >= 0);
    return s;
  }
  return s;
}

string checkapostroph(string s) {  // da der ganze String in ' eingeschlossen wird,
                                   // müssen die Apostrophen verdoppelt werden.
  string t[];
  int cnt;
  cnt = strsplit(t, s, '\''); // check Apostroph
  if (cnt > 1) {
    s = "";
    for (int i = 0; i < cnt; i++) {
      if (i == 0) {
        if (t[i]) s += t[i];
      }
      else if (i) s += "''" + t[i];
    }
  }
 return s;
}

int makedir(string root1, string subdir, string os) {  /*** generate DOS command MKDIR ***/
  if (os == "WINDOWS") {
	string DOScommand;
	sprintf(DOScommand, "CMD.EXE  /C MKDIR \"%s%s\"",  lash2backslash(root1, os), lash2backslash(subdir, os));
	system(DOScommand);
	string f[];
	int n = fileglob(f, root1 + subdir); // prüfe ob das Verzeichnis angelegt werden konnte.
	return n;
  }
  else {
	string command;
	sprintf(command, "mkdir %s%s", lash2backslash(root1, os), lash2backslash(subdir, os));
	system(command);
	string f[];
	int n = fileglob(f, root1 + subdir); // Confirm directory was created.
	return n;
  }
}

void call_system(string exportfile, string os) {  // DOS comand execute
  if (os == "WINDOWS") {
	string syscommand;
	// Das executable und der Dateiname müssen in " " eingeschlossen werden, wegen Spaces im Pfad-Dateinamen!
	sprintf(syscommand, "\"%s\" \"%s\"", lash2backslash(LTSpiceExecute, os), lash2backslash(exportfile, os));
	system(syscommand);  // externes Programm starten
	return;
  }
}

void dosfilecopy( string source, string target, string option, string os) {
  if (os == "WINDOWS"){
	string DOScommand;
	sprintf(DOScommand, "XCOPY \"%s\" \"%s\" %s", lash2backslash(source, os), lash2backslash(target, os), option);
	/*
	dlgDialog("DOS command") {
	  dlgHBoxLayout dlgSpacing(800);
	  dlgStringEdit(DOScommand);
      dlgPushButton("ok") dlgAccept();
      dlgPushButton("esc") { dlgReject(); exit(-4056); }
    };
    */
	system(DOScommand);
	return;
  }
}
